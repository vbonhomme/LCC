{
    "contents" : "# we load required packages\nlibrary(dplyr)\n\nrm(list = ls())\n\n.LCC_check <- function(path=path){\n  # checks for presence of data files ######\n  go <- TRUE\n  lf <- list.files(pattern=\".csv\")\n  if (!\"FireA.csv\" %in% lf) {\n    cat(\" * 'FireA.csv' is missing \\n\")\n    go <- FALSE\n  }\n  if (!\"FireC.csv\" %in% lf) {\n    cat(\" * 'FireC.csv' is missing \\n\")\n    go <- FALSE\n  }\n  if (!\"FireAsc.csv\" %in% lf) {\n    cat(\" * 'FireAsc.csv' is missing \\n\")\n    go <- FALSE\n  }\n  if (!\"FireCsc.csv\" %in% lf) {\n    cat(\" * 'FireCsc.csv' is missing \\n\")\n    go <- FALSE\n  }\n  # we use this flag to go ahead or stop\n  if (!go) stop()\n\n  # imports data files #########################################################\n  FireA   <<- read.csv(\"FireA.csv\", header=TRUE, sep=\";\")\n  FireAsc <<- read.csv(\"FireAsc.csv\", header=TRUE, sep=\";\")\n  FireC   <<- read.csv(\"FireA.csv\", header=TRUE, sep=\";\")\n  FireCsc <<- read.csv(\"FireAsc.csv\", header=TRUE, sep=\";\")\n  Smpl    <<- read.csv(\"Smpl.csv\",  header=TRUE, sep=\";\")\n  Seedle  <<- read.csv(\"Seedle.csv\", header=TRUE, sep=\";\")\n\n  # checks column names ########################################################\n  # same idea as above for the ok flag\n  ok <- TRUE\n  # column names\n  if (!identical(colnames(Seedle), c(\"Depth\", \"SdlCounts\", \"SdlArea\"))) {\n    cat(\" * Seedle.csv must contain three columns named 'Depth', 'SdlCounts' and 'SdlArea'\\n\")\n    ok <- FALSE\n  }\n\n  if (!identical(colnames(Smpl), c(\"Depth\", \"Age_calBP\", \"SmplCount\", \"SmplArea\"))) {\n    cat(\" * Smpl.csv must contain three columns named 'Depth', 'Age_calBP', 'SmplCount' and 'SmplArea'\\n\")\n    ok <- FALSE\n  }\n  if (!ok) stop()\n}\n\n\n.LCC_match <- function(Fire_file){\n  Fire_file <- read.csv(Fire_file, header=T,sep=\";\")\n  # we prefer this column selection rather than named columns since the .csv\n  # returned by CharAnalysis is not really clean\n  CC.peaks  <- Fire_file[, 19] #peak final\n  CC.cpeak  <- Fire_file[, 8] #char peak\n  CC.thresh <- Fire_file[, 12]  #threshold final\n  CC.age    <- Fire_file[, 2] #Age\n  CC.res    <- diff(CC.age[1:2]) #resolution temporelle entre la profondeur 1 et 2\n\n\n  # we subset Fire_file to create a data.frame that will be used throughout the process\n  CC <- select(Fire_file,\n               peaks  = 19, # peaks final\n               cpeak  = 8,  # char peak\n               thresh = 12, # threshold final\n               age    = 2)  # Age\n\n  # we add a new column, a logical : whether cpeak is above threshold\n  # §§§§ ne faudrait-il pas un >= plutôt ? je pense que les conséquences ne sont que psychologiques\n  CC <- mutate(CC, above = cpeak > thresh)\n\n  # we deduce the temporal resolution\n  .res <- diff(Fire_file[1:2, 2]) # temporal resolution\n\n\n  peakC.ind = which(CC$peaks==1) # where we have peaks in CC\n  peakC.n   = length(peakC.ind)  # and how many\n\n  Smpl <- select(Smpl,\n                 Area = 4,  # sum of areas per sample\n                 Age_calBP = 2, # sample age\n                 Count = 3, # charcoal number\n                 Depth = 1) # their depth\n\n\n  # where to store results\n  overthresh.indC <- peakCsamples.ind <- peakCsamples.count <- peakCsamples.area <- peakCsamples.age <- list()\n  overthresh.intervalC <- matrix(NA, nrow=length(peakC.ind), ncol=2)\n  # cosmectics\n  # §§§§ au choix, on peut la lever, mais ça fait une matrice plus jolie qu'on retourne à la fin, parmi d'autres\n  # tous les \"cosmetics\" réfèrent à ce genre de make-up. si ça te plait pas, on dégage.\n  nice_names <- paste0(\"peak\", 1:peakC.n)\n  dimnames(overthresh.intervalC) <- list(nice_names, c(\"ends\", \"starts\"))\n\n  # detects contiguous TRUEs in 'set', starting from the bottom-th position and going backward. returns the top-th position\n  find_top <- function(set, bottom){\n    top <- bottom\n    while (set[top]) {\n      top <- top - 1\n      if (top == 0) break # if set starts with TRUEs\n    }\n    return(top + 1)\n  }\n\n  # we loop over every peak to find which samples contribute to every peak\n  for (i in seq(along=peakC.ind)){\n    bottom.i <- peakC.ind[i]\n    top.i <- find_top(CC$above, bottom.i)\n    overthresh.intervalC[i, ] <- c(CC$age[top.i], CC$age[bottom.i] + .res)\n\n    # identify all samples contributing to the peak\n    peakCsamples.ind[[i]] <- which(Smpl$Age_calBP >= overthresh.intervalC[i, 1] &\n                                     Smpl$Age_calBP <= overthresh.intervalC[i, 2])\n\n    # we add (if not already included) the sample which is just above\n    dy <- overthresh.intervalC[i, 1] - Smpl$Age_calBP\n    peakCsamples.ind[[i]] <- union(peakCsamples.ind[[i]], which.min(dy[dy>0]))\n\n    # we finally extract original count, area and age data\n    peakCsamples.count[[i]] <- Smpl$Count[ peakCsamples.ind[[i]] ]\n    peakCsamples.area[[i]]  <- Smpl$Area[  peakCsamples.ind[[i]] ]\n    peakCsamples.age[[i]]   <- Smpl$Age_calBP[ peakCsamples.ind[[i]] ]\n  }\n\n  # cosmetics\n  names(peakCsamples.count) <- names(peakCsamples.area) <- names(peakCsamples.age) <- names(peakCsamples.ind) <- nice_names\n\n\n  ############ Calculates large and small charcoals for every depth\n  area_threshold <- 0.1 # argument\n  Seedle <- filter(Seedle, SdlCounts != 0) %>%                    # removes empty\n    mutate(Se.area.inf = ifelse(SdlArea < area_threshold, 1, 0),  # col with 1=small, 0=large\n           Se.area.sup = ifelse(SdlArea >= area_threshold, 1, 0)) # col with 0=small, 1=small\n\n  # we merge by $Depth and remove empty depths\n  dates2 <- merge(Seedle, Smpl,by=\"Depth\",all=TRUE) %>% na.omit()\n  # we count, by Age_calBP\n  Samp <- summarize(group_by(dates2, Age_calBP),\n                    Suminf = sum(Se.area.inf),\n                    Sumsup = sum(Se.area.sup))\n\n  # §§§§§ pas sur d'avoir compris ce délire là (lignes 135:138 de ton script originel), même si les résultats sont les mêmes\n  dates <- merge(data.frame(Age_calBP = unlist(peakCsamples.age)), Samp, by=\"Age_calBP\", all.x=FALSE)\n\n  # we attribute a unique number to peaks, according to the number of ages they encompass\n  res2 <- data.frame(pic=rep(1:peakC.n, times = sapply(peakCsamples.age, length)), Age_calBP=unlist(peakCsamples.age))\n  # we merge it with dates\n  dates<-merge(dates, res2, by=\"Age_calBP\",all= TRUE)\n  # we assign a number of fires to every peak, for every depth\n  dates<-merge(dates, Smpl, by=\"Age_calBP\",all.x= TRUE)  #assigne un num?ro de feux ? chaque pic sur la totalit? des  profondeurs constituant le pic\n  # we replace NAs with 0s\n  dates<-replace(dates,is.na(dates),0)\n  # ugly but turns factors into numbers\n  dates$Suminf <- as.numeric(as.character(dates$Suminf))\n  dates$Sumsup <- as.numeric(as.character(dates$Sumsup))\n\n  ############ Calculates large and small charcoals for every depth\n  FireCount <- group_by(dates, pic) %>%\n    summarize(Sinf=sum(Suminf), Ssup=sum(Sumsup), Sarea=sum(Area), Age_calBP=max(Age_calBP)) %>%\n    mutate(Count = Sinf + Ssup) %>%\n    # §§§ cosmetics (capitale)\n    rename(Pic=pic) %>%\n    # we calculate the FRI §§§§ on le fait là, plus logique et aussi Dmax est substitué par Age_calBP direct. ok pour ça ?\n    mutate(FRI = c(diff(Age_calBP), NA)) %>%\n    # §§§ cosmectics, reorder columns\n    select(Pic, Age_calBP, FRI, Count, Sinf, Ssup, Sarea) %>%\n    unique()\n\n  return(FireCount)\n}\n\n.LCC_wdw <- function(file, min.charnb = 10,\n                     wdw.increment = 400, wdw.width = 1000,\n                     FUN = median){\n  FireCount <- file\n  # we import the file. if not provided, choose it interactively\n  #     if (missing(file)) file <- file.choose()\n  #     Firecount <- write.csv(file=file, h=TRUE, sep=\",\")\n  #\n  # we retain peaks that have at least min_charnb\n  # §§§ un >= me paraitrait plus logique ici (eg 'au moins 10', plutôt que 'plus de 10'. kétenpenses ?\n  peaksC <- filter(FireCount, Count > min.charnb)\n\n  #D?finir les fen?tres coulissantes\n\n  top_i <- seq(min(Smpl$Age_calBP), max(Smpl$Age_calBP), by=wdw.increment)\n  bottom_i <- top_i + wdw.width\n  wdw <- data.frame(top_i, bottom_i)\n\n  # we loop over peaksC to retain only peaks which large charcoals\n  # are above the threshold function (median by default) within every peak\n\n  # we create a list to store results\n  pic_fenetreok <- list()\n\n  for (i in 1:nrow(wdw)){\n    # a subset encompassed within the i-th frame of the window\n    peaksC_i <- filter(peaksC, Age_calBP > wdw$top_i[i] & Age_calBP <= wdw$bottom_i[i])\n    # the thresold value\n    cut_i   <- summarize(peaksC_i, FUN(Ssup)) %>% as.numeric()\n    # a subset of the subset\n    pic_fenetreok[[i]] <- filter(peaksC_i, Ssup > cut_i)\n  }\n  # we bind them all\n  pic_fenetreok <- bind_rows(pic_fenetreok) %>% unique()\n  return(pic_fenetreok)}\n\n\n\n#' Performs Large Charcoal Count method\n#'\n#' @param path the path where to find the required files. \\code{getwd()} by default\n#' @param write.csv \\code{logical} whether to write \\code{.csv} files\n#' @param min.charnb \\code{numeric} minimum number of charcoals in a peak to retain it (10 by default)\n#' @param wdw.increment \\code{numeric} the increment for sliding the window (400 by default)\n#' @param wdw.width \\code{numeric} the width of the moving window (1000 by default)\n#' @param FUN \\code{function} returning a scalar, to apply to the charcoal retrieved within\n#' a moving window. (\\code{median} by default)\n#'\n#' @return a list with two components : \\code{$Area} and \\code{$Count}, each of them\n#' containing three components: \\code{$raw} (raw results from CharAnalysis),\n#' \\code{$sc} screened results with ARCO and \\code{$LCC} screening with the LCC methods.\n#'\n#' \\code{$Area} and \\code{$Count} can be passed directly to \\link{plot_screening}.\n#' @details\n#' This functions needs several input data, in 'path', by default the current working directory.\n#' Have a look to those provided available theregi: 'http://www.github/vbonhomme/LCC/data.zip'\n#'\n#' I. Raw data:\n#'\n#' I.1. \\strong{Seedle.csv}: a .csv table with charcoal-particle areas.\n#' Must have three columns and as many rows as the number of observations. These columns\n#' must be labelled as follows:\n#' \\itemize{\n#' \\item 'Depth': depth of samples\n#' \\item 'SdlCounts': number of charcoal particles in each sample\n#' \\item 'SdlArea': charcoal-particle areas\n#' }\n#'\n#' I.2. \\strong{Smpl.csv}: a .csv table with charcoal counts and charcoal areas.\n#' Must have four columns and as many rows as the number of samples. These columns\n#' must be labelled as follows:\n#' \\itemize{\n#' \\item 'Depth': depth of samples\n#' \\item 'Age_calBP': age estimate of samples\n#' \\item 'SmplCount': number of charcoal particles in each sample\n#' \\item 'SmplArea': cumulative charcoal area in each sample\n#'}\n#'\n#' II. Fire episode reconstructions:\n#' These are output files from the\n#' \\itemize{\n#'\n#' \\item CharAnalysis program by Higuera et al. (2009), which\n#' is freely available there \\url{http://sites.google.com/site/charanalysis/}.\n#' \\item ARCO by Finsinger et al. (2014) which is freely available there \\url{https://github.com/wfinsinger/ARCO}\n#'}\n#'\n#' In file names below, A stands for Area; C for counts; sc for screening with ARCO.\n#'\n#' \\itemize{\n#' \\item 'FireA.csv': CharAnalysis output table from analysis of CHARCOAL AREAS\n#' \\item 'FireAsc.csv': CharAnalysis output table from analysis of CHARCOAL AREAS and\n#'  WITH ARCO, with those parameters \\code{n.boot=10000}, \\code{thresh.prob=0.95},\n#' \\code{win.width=1000} and \\code{breakage=FALSE}. Also, \\code{minCountP} must be < 1.0\n#' (e.g. 0.05 as in Higuera et al. 2009)\n#' \\item 'FireC.csv': CharAnalysis output table from analysis of CHARCOAL COUNTS\n#' \\item 'FireCsc.csv': CharAnalysis output table from analysis of CHARCOAL COUNTS and\n#' with minimum count test, i.e. with CharAnalysis parameter \\code{minCountP < 1.0}, e.g. 0.05 as in Higuera et al. (2009).\n#'  }\n#'\n#'  Note that relevant information from all CharAnalysis is done via column number because\n#'  columns names are poorly formatted. Thus, files must have columns in the expected order, specifically:\n#'  \\itemize{\n#'  \\item Column 2:  'age Top_i', the age at the top of the interpolated sample\n#'  \\item Column 8:  'char Peak', the Cpeak component of CHAR\n#'  \\item Column 12: 'thresh FinalPos', the threshold used for peak identification\n#'  \\item Column 19: 'peaks Final', the boolean series representing identified peaks.\n#'  }\n#'\n#' @references\n#'\n#' The method is detailed in a submitted (2015) paper by Remy et al.\n#'\n#' Papers cited in the 'Details' section:\n#'\\itemize{\n#' \\item Finsinger, W., R. Kelly, J. Fevre, and E.K. Magyari (2014). A guide to screening\n#'     charcoal peaks in macrocharcoal-area records for fire episode reconstructions.\n#'     \\emph{The Holocene} 24(8):1002-108.\n#'     It can be found there \\url{http://hol.sagepub.com/content/24/8/1002}\n#'\n#' \\item Higuera, P.E., L.B. Brubaker, P.M. Anderson, F.S. Hu, and T.A. Brown (2009)\n#'     Vegetation mediated the impacts of postglacial climate change on fire regimes in\n#'     the south-central Brooks Range, Alaska. Ecological Monographs 79(2) 201:219.\n#'    It can be foudn there \\url{http://www.esajournals.org/doi/abs/10.1890/07-2019.1}\n#'    }\n#' @examples\n#' \\dontrun{\n#' # If you have all required files in your working directory.\n#' # You can find a .zip with example data there: 'http://www.github/vbonhomme/LCC/data.zip'\n#' results <- LCC()\n#' plot_screening(results$Area, \"Area\")\n#' plot_screening(results$Count, \"Count\")\n#' # Also, you should now have FireA, FireAsc, FireC, FireCsc, Seedle and Smpl\n#' available in your environment.\n#' # if write.csv=TRUE, you should also have .csv files in your working directory.\n#' }\n#' @export\nLCC <- function(path=getwd(), write.csv=FALSE,\n                min.charnb = 10,\n                wdw.increment = 400,\n                wdw.width = 1000,\n                FUN = median){\n  .LCC_check(path)\n\n  FireA_raw <- .LCC_match(\"FireA.csv\")\n  FireA_sc  <- .LCC_match(\"FireAsc.csv\")\n  FireA_LCC <- .LCC_wdw(FireA_sc,\n                        min.charnb = min.charnb,\n                        wdw.increment = wdw.increment,\n                        wdw.width = wdw.width,\n                        FUN = median)\n\n  Area <- list(raw = FireA_raw,\n               sc  = FireA_sc,\n               LCC = FireA_LCC)\n\n  FireC_raw <- .LCC_match(\"FireC.csv\")\n  FireC_sc  <- .LCC_match(\"FireCsc.csv\")\n  FireC_LCC <- .LCC_wdw(FireC_sc)\n\n  Count <- list(raw = FireC_raw,\n                sc  = FireC_sc,\n                LCC = FireC_LCC)\n\n\n  if (write.csv) {\n    write.csv(FireA_raw, file=\"FireA_raw.csv\", row.names = FALSE)\n    write.csv(FireA_sc,  file=\"FireA_sc.csv\", row.names = FALSE)\n    write.csv(FireA_LCC, file=\"FireA_LCC.csv\", row.names = FALSE)\n    write.csv(FireC_raw, file=\"FireC_raw.csv\", row.names = FALSE)\n    write.csv(FireC_sc,  file=\"FireC_sc.csv\", row.names = FALSE)\n    write.csv(FireC_LCC, file=\"FireC_LCC.csv\", row.names = FALSE)\n  }\n\n  return(list(Area=Area, Count=Count))\n}\n\n\n#' Plot the screening\n#'\n#' Typically after an LCC() step, plots the fire detected by the three methods\n#' @param list_screening an object from LCC (either $Area or $Count)\n#' @param title \\code{character} a title for the plot\n#' @examples\n#' \\dontrun{\n#' # see LCC examples.\n#' }\n#' @export\nplot_screening <- function(list_screening, title=\"\"){\n  if (!identical(c(\"raw\", \"sc\", \"LCC\"), names(list_screening)))\n    stop(\" * list_screening must contains '$raw', '$sc' and '$LCC' components\")\n  Fire_raw <- list_screening$raw\n  Fire_sc  <- list_screening$sc\n  Fire_LCC <- list_screening$LCC\n  FireALL  <- bind_rows(Fire_raw, Fire_sc, Fire_LCC)\n  add_pts <- function(x, y, pch, ...){points(x$Age_calBP, rep(y, nrow(x)), pch=pch, ...)}\n\n  par(mar=c(3, 1, 1, 1))\n  ma <- max(FireALL$Age_calBP)\n  plot(NA, xlim=c(max(FireALL$Age_calBP), 0), ylim=c(1, 6), ann=FALSE, frame=FALSE, axes=FALSE)\n  add_pts(Fire_raw, 4, 19, col=\"grey50\")\n  add_pts(Fire_sc, 3, 19, col=\"grey20\")\n  add_pts(Fire_LCC, 2, 17, col=\"grey20\")\n  axis(1, at=c(seq(0, ma, by=500), ma))\n  legend(\"topright\", pch = c(19, 19, 17), col=c(\"grey50\", \"grey20\", \"grey20\"),\n         legend = c(\"CharAnalysis\", \"Screened\", \"LCC\"), bty=\"n\")\n  title(title, line=-2)\n}\n\n\n\n######\n\n\n\n\n\n\n",
    "created" : 1427885557222.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3398692204",
    "id" : "2DCF36A6",
    "lastKnownWriteTime" : 1427890013,
    "path" : "~/Research/LCC/R/LCC.R",
    "project_path" : "R/LCC.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}